<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>
	UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf (28-32 fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:           
        </para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/uml.png" contentwidth="6in"/>
            </imageobject>
        </mediaobject>
        <para>
            Ebben a feladatban a BevProgon és Prog1-en már tárgyalt <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/vedes/elso/z3a7.cpp">z3a7.cpp</link> program forrásából kellett UML diagramot létrehozni. Én ehhez a <link xlink:href="https://www.visual-paradigm.com/">Visual Paradigm</link> 30 napos ingyenes próbaverzióját használtam. A diagramot roppant egyszerű legenerálni. A visual paradigm feltelepítése és elindítása után oda kell navigálnunk, hogy Tools > Code > Instant Reverse..., majd pedig ki kell választani, hogy milyen nyelvű forrásból szeretnénk diagramot generálni, és meg kell adni a fájl helyét. Ezek után már csak ki kell választani azokat az osztályokat, amelyeket meg szeretnénk mutatni a diagrammon, és kész is. Az általam generált diagramot a fentebb található képen lehetett látni.
        </para>
	<para>
	Ezen kívűl rá kell mutatni az aggregáció és kompozíció kapcsolatára. Azonban, mielőtt ezt megtehetnénk, először az asszociáció fogalmát kell tisztázni.
	</para>
	<para>
	Ha egy modellben két osztálynak kommunikálnia kell egymással, akkor szükségünk van egy kapcsolatra a két osztály között. Ezt a kapcsolatot reprezentálja az asszociáció. Az asszociációt egy a két osztály között lévő vonal, valamit az azon lévő irányt mutató nyil(ak) jelöli(k). Ha a vonal mindkét oldalán van nyíl, akkor az asszociáció kétirányú.
	</para>
	<para>
	Az aggregáció és kompozíció az asszociáció részhalmazai, vagyis az asszociáció különleges esetei. Mind a két esetben egy osztály objektuma "birtokol" egy másik osztály másik objektumát, de van a kettő között egy kis különbség.
	</para>
	<para>
	Az aggregáció egy olyan kapcsolatot jelent, amiben a gyerek a szülőtől függetlenül létezhet. Például ha van tanóra, ami a szülőosztály, és tanuló, ami a gyerekosztály. Ha töröljük a tanórát, attól a tanulók még léteznek.
	</para>
	<para>
	Ezzel szemben a kompozíció esetében egy olyan kapcsolatról van szó, amiben a gyerek nem létezhet a szülő nélkül. Például ha van egy ház szülőosztályunk, és egy szoba gyerekosztályunk. A szoba nem létezhet a ház nélkül.
	</para>
	<para>
	Az aggregációt és a kompozíciót is vonal+rombusz kombinációval lehet jelölni, azonban az aggregációnál a rombusz üres, a kompozíciónál pedig nem.
	</para>
	<para>
	Ezek alapján meg tudjuk mondani, hogy a fentebb látható ábrán a <programlisting><![CDATA[Csomopont gyoker;]]></programlisting> elem a kompozíció.
	</para>
	
    </section>

   <section>
        <title>Forward engineering UML osztálydiagram</title>
        <para>
	UML-ben tervezzünk osztályokat és generáljunk belőle forrást!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Mandelbrot">https://github.com/raczandras/progbook/tree/master/src/prog2/Mandelbrot</link>                
        </para>
        <para>
            Ebben a feladatban UML-ben kellett osztályokat megtervezni, majd pedig a diagramból forrást generálni. Én ehhez a feladathoz, ha már Mandelbrot a csokor neve, a MandelbrotHalmazt próbáltam meg lemodellezni a visual paradigm nevű szoftver segítségével. Ehhez a következő diagrammot sikerült összeállítani:
        </para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/genuml.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
  	<para>
	Ahogy láthatjuk a MandelbrotIterációk forrásfájl nagyító objektuma asszociációban áll a MandelbrotHalmazNagyító osztállyal, ami pedig kompozícióban áll a MandelbrotHalmaz osztállyal. Ezek után a kód generálása már gyerekjáték. Annyit kell tenni, hogy rákattintunk a Tools > generate java code... opcióra, majd pedig a kapott menüben megadjuk azt, hogy hova szeretnénk generálni a forrást, és a visual paradigm automatikusan legenerálja nekünk. Ha a fent megjelölt forrást összehasonlítjuk az eredetivel, akkor elmondhatjuk, hogy a generált forrás nagyon hasonlít az eredetire, hiszen a források szerkezete megyegyezik.
	</para>
	<programlisting>
	<![CDATA[public void update(java.awt.Graphics g) {
		// TODO - implement MandelbrotHalmaz.update
		throw new UnsupportedOperationException();
	}

	public void pillanatfelvétel() {
		// TODO - implement MandelbrotHalmaz.pillanatfelvétel
		throw new UnsupportedOperationException();
	}

	public void run() {
		// TODO - implement MandelbrotHalmaz.run
		throw new UnsupportedOperationException();
	}

	public int getSz() {
		// TODO - implement MandelbrotHalmaz.getSz
		throw new UnsupportedOperationException();
	}

	public int getM() {
		// TODO - implement MandelbrotHalmaz.getM
		throw new UnsupportedOperationException();
	}

	public java.awt.image.BufferedImage kép() {
		// TODO - implement MandelbrotHalmaz.kép
		throw new UnsupportedOperationException();
	}

	/**
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO - implement MandelbrotHalmaz.main
		throw new UnsupportedOperationException();
	}]]>
	</programlisting>
	<para>
	Ez a generált forrásnak egy része. És ha ezt összehasonlítjuk az eredeti forrássnak ugyan ezen részével, akkor észrevehetjük, hogy a két forrás szerkezete megegyezik, viszont nyílvánvalóan, ha kódot generálunk, akkor csak a függvények létrehozása történik meg, a törzsük viszont üres marad. Azonban, ha már valakinek összeállt a fejében egy ötlet arról, hogy hogyan fog kinézni a forrásának a felépítése, akkor annak az embernek nagyon jól tud jönni, ha azt a vázat létre tudja hozni egy UML diagramban, és abból generálni tud forrást.
	</para>
   </section>

   <section>
        <title>Egy esettan</title>
        <para>
	A BME-s C++ tankönyv 14. fejezetét (427-444 elmélet, 445-469 az esettan) dolgozzuk fel!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Mandelbrot/esettan">https://github.com/raczandras/progbook/tree/master/src/prog2/Mandelbrot/esettan</link>                
        </para>
        <para>
            Ebben a feladatban a Szoftverfejlesztés C++ nyelven című könyvben szereplő részletet kellett feldolgozni. Az elméleti része főképp az UML nyelvet mutatja be. Szó esik az osztálydiagrammokról, azon belül az osztály nevéről, az osztály attrubútumairól. illetve az osztály műveleteiről is. Majd pedig a láthatóságról. Ezeken kívűl megmagyarázza a különböző kapcsolatokat az objektumok között, azaz szó esik az asszociációkról, a kompozíciókról, illetve az aggregációkról, valamint ezek szerepéről és működésükről is. Végül pedig a sablonokról, illetve a kódgenerálásról és a kód visszafejtésről. Ezen belül arról, hogy pontosan mik ezek, ugye forward és reverse engineering, amikről az első két feladat szólt. Éppen ezért lehet hogy nem utolsóként kellett volna megcsinálni ezt a feladatot, hanem elsőként. Mivel nagy segítség lehetett volna a többi feladat megoldásánál, ha már ismerem ezeket a dolgokat.
        </para>
	<para>
	Ezek után következett maga az esettanulmány, ami egy program elkészítéséből állt. Maga a feladat egy számítógép kereskedéssel volt kapcsolatos. Eléggé összetett programról van szó, ami támogatja a termékek állományból való betöltését, képernyőre történő listázását, állományba való kiírását, és az árképzés rugalmas alakítását. És ha ez még nem lenne elég, még a lehetséges jövőbeli befektetésekre is gondolni kell, azaz a teljesen új termékcsaládok értékesítésének bevezetésére is lehetőséget kell biztosítani. Magához a feladathoz nagyon sok forrás meg volt adva, azonban így is meg kellett írni pár dolgot saját magunktól.
	</para>
	<para>
	Mivel a függvények, és az osztályok pontos működése teljes mértékben le van írva a könyvön belül, ezért én arról csak nagyon röviden és tömören szeretnék írni. A product a fő szülőosztálya az egésznek. Ez egybefoglal minden létező terméket, amit a bolt kínál. Ebből van származtatva a Display, a HardDisk, illetve a CompositeProduct osztályok, A CompositeProduct esetében összetett termékekről beszélünk, aminek például egy esete a belőle származtatott ComputerConfiguration osztály. Ezek mellé jönnek a ProductFactory, és a ComputerProductFactory osztályok, amelyek az egyes termékeket hozzák létre. Ha leteszteljük az elkészült alkalmazást akkor a következő eredményt kapjuk:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/esettan.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>BPMN</title>
        <para>
	Rajzoljunk le egy tevékenységet BPMN-ben!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf (34-47 fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Ebben a feladatban BPMN-ben, azaz Business Process Model and Notation használatával kellett modellezni valamit. Maga a BPMN egy folyamatábra, egy grafikai reprezentációja az üzleti folyamatoknak. Az UML-hez hasonlóan szintén egy modellező eszköz. Az én példám egy mindennapi esetet ír le, egy csomag megrendelését egy webáruházból, vagyis, hogy mi történik a között, hogy a vásárló megrendeli, és megkapja a csomagot. Ennek a feladatnak a megoldásához a visual paradigm nevű szoftvert választottam. A folyamatábra a következőképpen néz ki:
        </para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/bpmn.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	Látható a folyamatábrán, hogy három különböző entitás dolgozik a csomagért. Az egyik a vásárló, aki a csomagot rendeli, a második a webáruház, ami a csomagot eladja, és a harmadik pedig egy futárszolgálat, ami pedig házhoz viszi a csomagot. Maga a folyamat rendkívűl egyszerű. Először is a vásárló meglátogatja a webáruházat, itt kezdődik a folyamatábra. Majd megkeresi a csomagot, amit rendelni szeretne. Ezek után jön egy elágazás, mégpedig hogy van e a keresett termék raktáron. Amennyiben nincs, úgy itt véget is ér a folyamat. Azonban ha van, akkor megrendeli. Itt történik egy interakció a vásárló és a webáruház között. A webáruház megkapja a rendelést, azt feldolgozza és előkészíti a szállításra. Ezek után két interakció is történik. Egyrészt a webáruház átadja a futárszolgálatnak a csomagot, másrészt pedig szól a vásárlónak, hogy át lett adva a csomagja a futárnak. Majd a futárszolgálat kiszállítja a csomagot a vevőnek, amit az átvesz és kifizet. Ezek után a vevő már csak használja a terméket, ezzel az ő folyamata véget ér. A futár pedig a kapott pénzt átadja a webáruháznak, és ezzel mindkettőjük folyamata véget ér. Ez nyílván egy nagyon egyszerű példa, amit lehetett volna sokkal bonyolultabb is, de a BPMN működésének a bemutatására tökéletes.
	</para>
	</section>
   <section>
        <title>BPEL Helló, Világ! - egy visszhang folyamat</title>
        <para>
	Egy visszhang folyamat megvalósítása az alábbi teljes „videó tutoriál” alapján:
https://youtu.be/0OnlYWX2v_I
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>TeX UML</title>
        <para>
	Valamilyen TeX-es csomag felhasználásával készíts szép diagramokat az OOCWC projektről (pl.
use case és class diagramokat).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>
