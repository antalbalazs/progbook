<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>Gengszterek</title>
        <para>
	Gengszterek rendezése lambdával a Robotautó Világbajnokságban https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>C++11 Custom Allocator</title>
        <para>
	https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

  <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
	Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/G%C3%B6del/stlmap">https://github.com/raczandras/progbook/tree/master/src/prog2/G%C3%B6del/stlmap</link>                
        </para>
        <para>
            Ebben a feladatban kulcs-érték párokat kellett rendezni. Alapvetően ezt kulcs alapján tennénk meg, viszont itt érték alapján kellett. Lássuk hogyan működik a program, kezdve a Map osztállyal:
        </para>
	<programlisting>
	<![CDATA[package stlmap;

public class Map 
{
    private String kulcs;
    private int ertek;
    
public Map( String[] tomb)
{
    kulcs = tomb[0];
    ertek = Integer.parseInt(tomb[1]);
    
}

    @Override
    public String toString() {
        return "kulcs=" + kulcs + ", ertek=" + ertek;
    }

    public String getKulcs() {
        return kulcs;
    }

    public int getErtek() {
        return ertek;
    }

    public void setKulcs(String kulcsra){
    	kulcs = kulcsra;
    }

    public void setErtek(int ertekre){
    	ertek = ertekre;
    }
    
}]]>
	</programlisting>
	<para>
	Itt látható, hogy a kulcs-érték párok egy osztályban vannak eltárolva, aminek a két tagváltozója a kulcs és érték. Mivel ezek privát tagváltozók, éppen ezért megtalálhatóak a hozzájuk tartózó setterek és getterek is. Ezeken kívűl van még egy <function>toString()</function> metódus is, ami kiírja az objektumok tagváltozóinak az értékeit. Érdemes még megemlíteni, hogy a konstruktor egy String tömböt kap, aminek az első eleme lesz az adott objektum kulcsa, a második eleme pedig az adott objektum értéke. Az, hogy ez miért van így, arra később fogok kitérni. Ez elég egyszerű, ezért térjünk is át magára a beolvasásra, illetve a rendezésre. Az egész úgy kezdődik, hogy megszámoljuk azt, hogy hány darab kulcs érték párunk van a feladat.txt nevű fájlban, majd pedig egy RandomAccessFile segítségével beolvassuk azokat a Map tömbbe: 
	</para>
	<programlisting>
	<![CDATA[public static void main(String args[] ){
		
	RandomAccessFile raf;
        String sor;
        Map[] tomb;
        int db;

        try
        {
            raf = new RandomAccessFile("stlmap/feladat.txt","r");
            db = 0;
            
            for( sor = raf.readLine(); sor!= null; sor = raf.readLine() )
            {
                db++;
            }

            tomb = new Map[db];
            db = 0;
            raf.seek(0);
            
            for( sor = raf.readLine(); sor != null; sor = raf.readLine() )
            {
                tomb[db] = new Map(sor.split(","));
                db++;
            }           
            raf.close();]]>
	</programlisting>
	<para>
	Négy változóval kezdünk. Az első a RandomAccessFile, ami a kulcs-érték párokat tartalmazó fájl elérési útját fogja tárolni, egy sor String, ami a beolvasásnál a fájl egy-egy sorát fogja tárolni, egy Map[] tomb, amibe a kulcs-érték párok kerülnek, illetve egy int db, amivel pedig a fájlban lévő sorok számát, illetve a tomb hosszát fogja megmondani. Ezek után inicializáljuk a RandomAccessFile-t és a db változót is, majd pedig egy for ciklussal megszámoljuk a sorok számát. Ezek után inicializáljuk a Map tömböt, a db változó értékét nullára állítjuk, és visszaugrunk a fájl elejére. Ezek után végigmegyünk a fájl sorain, amikben a kulcs-érték párok vesszővel vannak elválasztva egymástól, éppen ezért a konstruktornak egy kételemű tömböt adunk át, ami az adott sor elválasztva a vesszőnél a <function>sor.split(",");</function> függvény segítségével.
	Ezek után kiíratjuk az eredeti tömbböt egy for each ciklussal, amit aztán shell rendezéssel rendezünk, majd pedig ismét kiírjuk a rendezett értékeket:
	</para>
	<programlisting>
	<![CDATA[System.out.println("eredeti értékek: ");

            for( Map i : tomb )
            {
                System.out.println(i.toString());
            }

            for( int gap = db / 2; gap > 0; gap /=2){
                for( int i = gap; i< db; i++){
                    Map temp= tomb[i];
                    int j;
                    for( j = i; j >= gap && tomb[j - gap].getErtek() > temp.getErtek(); j -= gap){
                        tomb[j] = tomb[j - gap];
                    }

                    tomb[j] = temp;
                }
            }
            System.out.println("\nRendezett értékek:");
            for( Map i : tomb){
                System.out.println(i.toString());
            }
        }
        catch(IOException e){
        	System.out.println("Hiba a beolvasas soran: "+e);
        }
	}
}]]>
	</programlisting>
	<para>
	A program működés közben pedig a következőképpen néz ki:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/stl.png" contentwidth="6in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>Alternatív Tabella rendezése</title>
        <para>
	Mutassuk be a https://progpater.blog.hu/2011/03/11/alternativ_tabella a programban a java.lang
Interface Comparable<programlisting><![CDATA[<T>]]></programlisting> szerepét!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Prolog családfa</title>
        <para>
	Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>GIMP Scheme hack</title>
        <para>
	Ha az előző félévben nem dolgoztad fel a témát (például a mandalás vagy a króm szöveges
dobozosat) akkor itt az alkalom!
        </para>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó:     
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>

        <para>
            Ez egy prog1-en már tárgyalt feladat, amiben egy gimp kiegészítőről van szó, amiben a bemenő szövegből egy név-mandala fog készülni. A mandala egy szimmetrikus kör alakú kép, ami a Hindu vallásban nagy szerepet játszik a Hindu istenek ábrázolásában. 
	Először a program meghatározza a szöveg hosszát, a kapott értéket a set! utasítással a text-width változó értékenek adja. A következő függvény a betűk méretét határozza meg. A szükséges méretekek a a GIMP beépített függvényeivel határozza meg a következőképpen. Alapvetően nem feltétlenül szükséges tudnunk a szöveghosszt a mandala előállításához, de ahhoz, hogy szép legyen a kép, ezt is tudnia kell a programnak. Ezt elég könnyű meghatározni, mivel a <function>gimp-text-get-extents-fontname</function> egy listát fog visszaadni, aminek a szöveghossz a legelső eleme, ami nekünk kell. Azt pedig a <function>car</function> függvénnyel határozzuk meg. A car függvény egy lista fejét adja vissza, jelen esetben a lista első elemét, pont ami nekünk kell.
	</para>  
      
	<programlisting>
<![CDATA[(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)

(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)

(define (text-wh text font fontsize)
(let*
    (
        (text-width 1)
        (text-height 1)
    )
    ;;;
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;; ved ki a lista 2. elemét
    (set! text-height (elem 2  (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;;    
    
    (list text-width text-height)
    )
)


;(text-width "alma" "Sans" 100)

(define (script-fu-bhax-mandala text text2 font fontsize width height color gradient)
(let*
    (
        (image (car (gimp-image-new width height 0)))
        (layer (car (gimp-layer-new image width height RGB-IMAGE "bg" 100 LAYER-MODE-NORMAL-LEGACY)))
        (textfs)
        (text-layer)
        (text-width (text-width text font fontsize))
        ;;;
        (text2-width (car (text-wh text2 font fontsize)))
        (text2-height (elem 2 (text-wh text2 font fontsize)))
        ;;;
        (textfs-width)
        (textfs-height)
        (gradient-layer)
    )
]]>
	</programlisting> 

	<para>
		Ezek után jön maga a mandala. Először létrejön egy réteg (layer) Amit feltöltünk a felhasználó által megadott adatokkal. Ezek a a szöveg, a szöveg betűtítusa, illetve a szöveg mérete. A felhasználó által megadott szöveget elhelyezzük a réteg közepére, a megadott betűtípussal és betűmérettel. Ezután a réteget vízszintesen tükrözi a program, és ráhelyezzük az eredeti réteg felé ezzel elérve a szimmetriát, majd a program elforgatja az így keletkezett képet először 90 majd 45 és végül 30 fokkal és minden egyes elforgatás után megismétli a tükrözést. Ezek után a szövegréteget felnagyítja a teljes réteg méretére.
	</para>
	<programlisting>
	<![CDATA[(gimp-image-insert-layer image layer 0 0)

    (set! textfs (car (gimp-text-layer-new image text font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text-width 2))  (/ height 2))
    (gimp-layer-resize-to-image-size textfs)

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate-simple text-layer ROTATE-180 TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 2) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 4) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))
    
    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 6) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))    
    
    (plug-in-autocrop-layer RUN-NONINTERACTIVE image textfs)
    (set! textfs-width (+ (car(gimp-drawable-width textfs)) 100))
    (set! textfs-height (+ (car(gimp-drawable-height textfs)) 100))
        
	(gimp-layer-resize-to-image-size textfs)
]]>
	</programlisting>
	<para>
	Ezután két körnek álcázott ellipszist illeszt a képre, amik a szöveget fogják kézrefogni. Az egyik kör vastagsága 8, a másiké pedig 22. Ezek után megtörténik a színátmenet egy új rétegre, és megjeleníttetjük a képet.
	</para>
	<programlisting>
	<![CDATA[(gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 22)
    (gimp-edit-stroke textfs)
    
    (set! textfs-width (- textfs-width 70))
    (set! textfs-height (- textfs-height 70))
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 8)
    (gimp-edit-stroke textfs)
        
    (set! gradient-layer (car (gimp-layer-new image width height RGB-IMAGE "gradient" 100 LAYER-MODE-NORMAL-LEGACY)))
    
    (gimp-image-insert-layer image gradient-layer 0 -1)
	(gimp-image-select-item image CHANNEL-OP-REPLACE textfs)
	(gimp-context-set-gradient gradient) 
	(gimp-edit-blend gradient-layer BLEND-CUSTOM LAYER-MODE-NORMAL-LEGACY GRADIENT-RADIAL 100 0 REPEAT-NONE FALSE TRUE 5 .1 TRUE 500 500 (+ (+ 500 (/ textfs-width 2)) 8) 500)
	
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)

    ;(gimp-selection-none image)
    ;(gimp-image-flatten image)
    
    (gimp-display-new image)
    (gimp-image-clean-all image)
    )
)
]]>
	</programlisting>
	<para>
	Ezek után már csak a GIMP-be regisztrálás van hátra.
	</para>
	<programlisting>
	<![CDATA[(script-fu-register "script-fu-bhax-mandala"
    "Mandala9"
    "Creates a mandala from a text box."
    "Norbert Bátfai"
    "Copyright 2019, Norbert Bátfai"
    "January 9, 2019"
    ""
    SF-STRING       "Text"      "STRING1"
    SF-FONT         "Font"      "Sans"
    SF-ADJUSTMENT   "Font size" '(100 1 1000 1 10 0 1)
    SF-VALUE        "Width"     "1000"
    SF-VALUE        "Height"    "1000"
    SF-GRADIENT     "Gradient"  "Deep Sea"
)
(script-fu-menu-register "script-fu-bhax-mandala" 
    "<Image>/File/Create/BHAX"
)
]]>
	</programlisting> 
    </section>

</chapter>
