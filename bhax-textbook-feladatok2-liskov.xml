<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
	Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a megoldásra: jobb OO tervezés. https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia) (számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-Barki/madarak/)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Liskov/liskovj.java">Java</link> 
	    <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Liskov/liskov.cpp">C++</link>               
        </para>
        <para>
            A liskov elv azt jelenti, hogy ha S altípusa T-nek, akkor minden olyan helyen ahol T-t felhasználjuk S-t is minden gond nélkül behelyettesíthetjük anélkül, hogy a programrész tulajdonságai megváltoznának. Vagyis ha S osztály T osztály leszármazottja, akkor S szabadon behelyettesíthető minden olyan helyre (paraméter, változó, stb…), ahol T típust várunk. Ezt kellett megsérteni c++ ban és java-ban is. Ehhez én egy madár-pingvin szülőosztály-gyerekosztály kombinációt használtam.
        </para>
	
	<para>
	C++:
	</para>
	<programlisting language="C++">
	<![CDATA[#include <iostream>
using namespace std;

class Madar {
public:
     void repul() {
	cout << "Repül";}
};

class Sas : public Madar
{};

class Pingvin : public Madar 
{};]]>
	</programlisting>
<para>
És java:
</para>
	<programlisting language="Java">
	<![CDATA[static class Madar{
	public void repul(){
	System.out.println("Repülök");
	}
}

static class Sas extends Madar{
	
}

static class Pingvin extends Madar{

}]]>
	</programlisting>
	<para>
	A programok mindkét esetben úgy kezdődnek, hogy létrehozzuk a szülőosztályt, ami a madár. Ennek az osztálynak van egy olyan metódusa, hogy <function>repul()</function> ami jelen esetben csak annyit csinál, hogy kiirja a konzolra azt, hogy Repül vagy Repülök. Majd jön két újabb osztály, amiket a Madárból származtatunk, vagyis ők is meg fogják kapni a <function>repul()</function> metódust. Az egyik osztály a sas, ami tud repülni és még madár is, szóval itt nincs probléma. Azonban a másik osztály a Pingvin, ami igaz, hogy madár, de repülni nem tud.
	</para>
	
	<para>
	C++:
	</para>
	<programlisting language="C++">
	<![CDATA[int main ( int argc, char **argv )
{
     Madar madar;
     madar.repul();
     cout << " a madár\n";

     Sas sas;
     sas.repul();
     cout << " a sas\n";

     Pingvin pingvin;
     pingvin.repul();
     cout << " a pingvin. De a pingvin nem tud repülni, ezért sérült a Liskov elv.\n";

}]]>
	</programlisting>
	<para>
	és Java:
	</para>
	<programlisting language="Java">
	<![CDATA[public static void main(String args[]){
	Madar madár = new Madar();
	Sas sas = new Sas();
	Pingvin pingvin = new Pingvin();
	
	System.out.print("Mit csinál a madár?:");
	madár.repul();
	
	System.out.print("\nMit csinál a sas?:");
	sas.repul();

	System.out.print("\nMit csinál a pingvin?:");
	pingvin.repul();
	System.out.println("\nDe a pingvin nem tud repülni, szóval sérül a liskov elv.");

}]]>
	</programlisting>
	<para>
	Ezek után a main-ben mind a két esetben példányosítunk, azaz létrehozunk egy madarat, egy sast és egy pingvint is. Majd mind a három objektummal meghívjuk a repül függvényt. Az első kettővel nincs, és nem is lenne gond, mivel alapvetően tudnak repülni, viszont a pingvin, mint tudjuk nem tud repülni. Azonban ez a pingvin ahelyett, hogy hibát dobna a program, boldogan repked a virtuális térben, ami nekünk nem jó.
	</para>
	<mediaobject>
            <imageobject>
                <imagedata fileref="pic/liskov.png"/>
            </imageobject>
        </mediaobject>
	<para>
	Erre egy megoldás a jobb OO tervezés. Vagyis ha például ha a Madár osztályunk megmadarna, de lenne két származtatott osztálya. Az egyik osztályba kerülnének a repülni tudó madarak, a másikba pedig azok a madarak, amik nem tudnak repülni. És ezekből az osztályokból származtathatnánk tovább a sast, ami egy repülni tudó madár, illetve a pingvint is, ami pedig nem tud repülni.
	</para>
    </section>

   <section>
        <title>Szülő-gyerek</title>
        <para>
	Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Liskov/SzuloGyerek.java">Java</link> 
	    <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Liskov/SzuloGy.cpp">C++</link>              
        </para>
        <para>
            Ebben a feladatban be kellett bizonyítani, hogy ha a gyerekosztályban létrehozunk egy metódust, akkor ha a gyerekosztályt szülőosztályként szeretnénk használni, akkor a gyerekosztály saját metódusait nem fogjuk tudni használni. Én az előző feladathoz hasonlóan maradtam a Madár-Sas példánál. A Madár a szülő, a Sas a gyerekosztály.
        </para>
	<para>
	C++ kód:
	</para>
	<programlisting>
	<![CDATA[class Madar{
public: 
	
};

class Sas : public Madar{
public:
	void repul() {
		std::cout << "Repül";
	}

};]]>
	</programlisting>
	<para>
	És java:
	</para>
	<programlisting>
	<![CDATA[static class Madar{
	protected int szarnyhossz;
	public void setSzarnyhossz(int szarnyhossz) {
	this.szarnyhossz = szarnyhossz;
	}

}

static class Sas extends Madar{
	public int getSzarnyhossz(){
		return szarnyhossz;
	}
}]]>
	</programlisting>

	<para>
	A C++ kód esetében a gyerekosztálynak van egy <function>repul()</function> metódusa, ami szimplán csak kiirja a konzolra, hogy "Repül". Ezzel szemben a java példa egy kicsit bonyolultabb, mivel itt a szülő osztálynak, azaz a madárnak van egy szárnyhossz tulajdonsága, illetve egy <function>setSzarnyhossz()</function> metódusa, amivel a szárnyhossz tulajdonságot lehet beállítani. A gyermek osztály természetesen megörökli ezt a tulajdonságot, illetve metódust, szóval neki is szabadon belehet állítani a szárnyhossz tulajdonságát. De ezek mellett van egy <function>getSzarnyhossz()</function> metódusa is, ami visszaadja a sas objektum szárnyhosszát. Ez eddig teljesen normális, az érdekesség akkor kezdődik, amikor a main-be érünk.
	</para>
	<para>
	C++:
	</para>
	<programlisting>
	<![CDATA[int main(){

	Madar* sas = new Sas();
	Sas* sas2 = new Sas();

	sas->repul();
	sas2->repul();
}]]>
	</programlisting>

	<para>
	És java:
	</para>
	<programlisting>
	<![CDATA[public static void main(String args[]){
		Madar sas = new Sas();
		sas.setSzarnyhossz(80);

		Sas sas2 = new Sas();
		sas2.setSzarnyhossz(50);
		
		System.out.println(sas2.getSzarnyhossz() + " " + sas.getSzarnyhossz() );
	}]]>
	</programlisting>
	<para>
	Mind a két esetben létrehozunk egy Sas típust Sas típusként, amivel nincs is gond, de létrehozunk egy Madár típust is Sas típusként. Ezek után a C++ kódban mind a két objektumok megpróbáljuk repteteni a <function>repul()</function> metódust használva. A Sas típusnak ezzel nem is lenne gondja, azonban a Madárnak igen.
	</para>
	<para>
	A java kód itt is egy kicsit másképp működik. Itt a két típus létrehozása után mind a kettőnek beállítjuk a szárnyhosszát a <function>setSzarnyhossz()</function> segítségével, amivel nincs is gond, mivel ez eredetileg a Madár osztály metódusa, amit a Sas megörökölt. Azonban ezek után a <function>getSzarnyhossz()</function> metódus segítségével megpróbáljuk kiiratni mind a két objektum szárnyhosszát, ami csak az egyik esetben sikerülne. A végeredmény pedig:
	</para>
	<mediaobject>
            <imageobject>
                <imagedata fileref="pic/szgy.png"/>
            </imageobject>
        </mediaobject>
	
    </section>

   <section>
        <title>Anti OO</title>
        <para>
	A BBP algoritmussal a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10<superscript>6</superscript>, 10<superscript>7</superscript>, 10<superscript>8</superscript> darab jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket! https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>deprecated - Hello, Android!</title>
        <para>
	Élesszük fel a https://github.com/nbatfai/SamuEntropy/tree/master/cs projektjeit és vessünk össze néhány egymásra következőt, hogy hogyan változtak a források!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Hello, Android!</title>
        <para>
	Élesszük fel az SMNIST for Humans projektet! https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

    <section>
        <title>Hello, SMNIST for Humans!</title>
        <para>
	Fejleszd tovább az SMNIST for Humans projektet SMNIST for Anyone emberre szánt appá! Lásd
az smnist2_kutatasi_jegyzokonyv.pdf-ben a részletesebb hátteret!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
	Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>
