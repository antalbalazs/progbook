<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>Port scan</title>
        <para>
	Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Lauda/KapuSzkenner.java">https://github.com/raczandras/progbook/blob/master/src/prog2/Lauda/KapuSzkenner.java</link>              
        </para>
        <para>
            Ebben a feladatban a kivételkezelésre kellett rámutatni a megadott forrásban. Nézzük is meg magát a forráskódot, illetve azt, hogy milyen eredményt ad a program futtatás közben:
        </para>
	<programlisting>
	<![CDATA[public class KapuSzkenner {    
    public static void main(String[] args) {
        
        for(int i=0; i<1026; ++i)
            
            try {                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");               
            }
    }   
}]]>
	</programlisting>
	<para>
	És a kép a futtatásról:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/port.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	Ebből annyit tudunk meg, hogy van egy for ciklus, ami 0-tól 1025-ig fut. Azon belül van egy try-catch szerkezet. A try-ban létrehozunk egy socket objektumot aminek ip címnek a legelső argumentum értékét, portnak pedig i aktuális értékét adjuk. Ilyenkor a program megpróbál a program egy TCP kapcsolatot létrehozni. Ha ez az utasítás nem dob exception-t, akkor kiiratjuk, hogy egy szerver folyamat figyeli a portot, vagy röviden: figyeli, és bezárja a program a socketet. Azonban, ha itt exception-t dob a program, akkor kiirja, hogy nem figyeli. Ezután egy kicsit módosítottam a programot annak érdekében, hogy megtudjam azt, hogy milyen exceptiont dob pontosan a try. A következő eredményt kaptam:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/port2.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	Mint azt láthatjuk, ha nem sikerül kialakítani a kapcsolatot, akkor egy ConnectException-t kapunk. Az oracle <link xlink:href="https://docs.oracle.com/javase/7/docs/api/java/net/ConnectException.html">dokumentációja</link> tisztán és érthetően megmagyarázza, hogy a ConnectException jelzi azt, hogy hiba történt egy socket egy távoli címhez és porthoz történő csatlakoztatásakor. Általában a kapcsolatot távolról tagadják meg, pl: egy folyamat sem figyeli a cím adott portját. Vagyis, ha sikerül kapcsolatot létrehoznia a programnak, akkor tudja, hogy azt a portot figyelik, ha pedig nem, akkor pedig tudja azt, hogy nem figyelik.
	</para>
    </section>

   <section>
        <title>AOP</title>
        <para>
	Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési
feladat volt korábban.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Android Játék</title>
        <para>
	Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Junit teszt</title>
        <para>
	A https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat
poszt kézzel számított mélységét és szórását dolgozd be egy Junit tesztbe (sztenderd védési feladat
volt korábban).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>OSCI</title>
        <para>
	Készíts egyszerű C++/OpenGL-es megjelenítőt, amiben egy kocsit irányítasz az úton. A kocsi
állapotát minden pillanatban mentsd le. Ezeket add át egy Prolog programnak, ami egyszerű reflex
ágensként adjon vezérlést a kocsinak, hasonlítsd össze a kézi és a Prolog-os vezérlést. Módosítsd
úgy a programodat, hogy ne csak kézzel lehessen vezérelni a kocsit, hanem a Prolog reflex ágens
vezérelje!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>
