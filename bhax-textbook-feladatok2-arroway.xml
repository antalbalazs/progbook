<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
	A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
<link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf</link> (16-22 fólia)
Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Arroway/Pol%C3%A1rGener%C3%A1tor.java">Java</link> 
	    <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Arroway/polargen.cpp">C++</link>       
        </para>
        <para>
            Ebben a feladatban a prog1-en már tárgyalt Polárgenerátor megírása volt a feladat. A lényege ennek a programnak az, hogy legelőször generál két értéket. Az egyik értéket eltárolja, a másikat pedig visszaadja. Majd amikor következőnek megint generálna, akkor először megnézi, hogy van e már tárolt érték. Ha van akkor azt a tárolt értéket adja vissza, ha viszont nincs, akkor generál két értéket, amiből az egyiket eltárolja, a másikat pedig visszaadja. Azt, hogy van e tárolt érték, egy boolean változóban tartja nyílván.
        </para>
	<para>
	A program a PolárGenerátor osztállyal kezdődik:
	<programlisting>
	<![CDATA[public class PolárGenerátor {
    boolean nincsTárolt = true;
    double tárolt;
    
    public PolárGenerátor() {
        nincsTárolt = true;
    }]]>
	</programlisting>
	Itt kezdőértéknek meg van adva, hogy nincs tárolt érték, valamint egy double változó a majdani tárolt értéknek.
	</para>
	<para>
	Ezek után következik a <function>következő</function> nevű függvény, ami az érdemi munkát végzi.
	Ha már van tárolt értékünk, akkor a nincsTárolt változó értékét az ellenkezőjére változtatja, és visszaadja a tárolt értéket. Ha viszont nincs, akkor egy do while ciklusban először is az u1 és u2 változókhoz két véletlenszerű értéket rendel, majd pedig a Vx változók értékét úgy határozza meg, hogy Ux-et megszorozza kettővel, és a kapott eredményből kivon 1-et. Ezek után a w változónak az értéke v1 négyzetének, és v2 négyzetének az összege. Ez a ciklus addig fog futni, amíg w értéke nagyobb mint 1. Ha véget ért a ciklus akkor az újonnan deklarált r változó kezdőértékét úgy határozza meg, hogy -2-vel megszorozza w logaritmusát, majd azt elosztja w-vel, és a kapott értéknek a négyzetgyöke lesz az eredmény. Ezek után a nincsTárolt változó értékét az ellenkezőjére állítja. Az eltárolt érték a r és v2 szorzata lesz, a visszaadott érték pedig r és v1 szorzata.
	<programlisting>
	<![CDATA[public double következő() {
        if(nincsTárolt) {
            double u1, u2, v1, v2, w;
            do{
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2* u1 -1;
                v2 = 2* u2 -1;
                w = v1 * v1 + v2 * v2;
            } while ( w > 1);
            double r = Math.sqrt((-2 * Math.log(w)) / w);
            tárolt = r * v2;
            nincsTárolt = !nincsTárolt;
            return r * v1;
        } else {
            nincsTárolt = !nincsTárolt;
            return tárolt;
        }
    }]]>
	</programlisting>
	</para>

	<para>
	Végül pedig a main, ami létrehoz egy PolárGenerátor objektumok, és egy for ciklussal 10 alkalommal futtatja a függvényt.
	<programlisting>
	<![CDATA[public static void main(String args[]){
       PolárGenerátor g = new PolárGenerátor();
       for ( int i = 0; i< 10; i++) {
           System.out.println(g.következő() );
       }]]>
	</programlisting>
	</para>
	<para>
	Az eredmény pedig:
	</para>
	<mediaobject>
            <imageobject>
                <imagedata fileref="pic/polar.png"/>
            </imageobject>
        </mediaobject>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java nyelvre, ugyanúgy működjön! Mutassunk rá, hogy gyakorlatilag a pointereket és referenciákat kell kiirtani és minden máris működik (erre utal a feladat neve, hogy Java-ban minden referencia, nincs választás, hogy mondjuk egy attribútum pointer, referencia vagy tagként tartalmazott legyen).
Miután már áttettük Java nyelvre, tegyük be egy Java Servletbe és a böngészőből GET-es kéréssel
(például a böngésző címsorából) kapja meg azt a mintát, amelynek kiszámolja az LZW binfáját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

	</section>

	<section>
        <title>Gagyi</title>
        <para>
            Az ismert formális <programlisting> <![CDATA[while(x <= t && x >= t && t != x);]]> </programlisting> tesztkérdéstípusra adj a szokásosnál (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t értékekkel meg nem! A példát építsd a JDK Integer.java forrására, hogy a 128-nál inkluzív objektum példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

	</section>

	<section>
        <title>Yoda</title>
        <para>
            Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
conditions-t! <link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">https://en.wikipedia.org/wiki/Yoda_conditions</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/Arroway/yoda.java">Forrás</link>                 
        </para>
        <para>
            A sokak által, köztük általam is tanult összehasonlítási módszer szerint az egyenlőségjel bal oldalára kell kerülnie a változónak minden esetben. Azonban ezzel van egy probléma. Ha annak a bizonyos változónak null az értéke, akkor a programunk le fog állni egy java.lang.NullPointerException-nel. Erre ad megoldást a Yoda conditions, aminek az a lényege, hogy az összehasonlítás bal oldalára írjuk az értéket, a jobb oldalára pedig a változót.
	<programlisting>
	<![CDATA[import java.util.Scanner;
public class Main {   
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String hason = null;
        String legyen;
        
        System.out.println("Kapjunk-e NullPointerException-t? I/N");
        for(;;){
            legyen = sc.nextLine();
            
            if( legyen.equalsIgnoreCase("I") ){
                if( hason.equals("abrakadabra") ){
                   break;
                }
            }
            
            else if( legyen.equalsIgnoreCase("N")){
                if(!"abrakadabra".equals(hason) ){
                    System.out.println("Nem Kaptunk.");
                    break;
                }
            }           
            else{
                System.out.println("Nem Tudom értelmezni amit írtál. próbáld újra.");
            }           
        }        
    }    
}]]>
	</programlisting>
	Ebben a példában a hason egy String aminek null az értéke. A felső elágazás során a program le fog állni a fent említett NullPointerException hibával, mivel a stringet egy null pointerhez hasonlítanánk, ami nem lehetséges. Ezzel szemben az alsó esetben szimplán csak egy hamis értéket fogunk kapni eredményként. És a végeredmény:
        </para>
	<mediaobject>
            <imageobject>
                <imagedata fileref="pic/yoda.png"/>
            </imageobject>
        </mediaobject>
	</section>

	<section>
        <title>Kódolás from scratch</title>
        <para>
            Induljunk ki ebből a tudományos közleményből: http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!Ha megakadsz, de csak végső esetben: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei</link>   (mert ha csak lemásolod, akkor pont az a fejlesztői élmény marad ki, melyet szeretném, ha átélnél).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

	</section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>                
