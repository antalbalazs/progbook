<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
	Javítsunk valamit a ActivityEditor.java JavaFX programon!
https://github.com/nbatfai/future/tree/master/cs/F6
Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/blob/master/src/prog2/hello/F6/ActivityEditor.java">https://github.com/raczandras/progbook/blob/master/src/prog2/hello/F6/ActivityEditor.java</link>                
        </para>
        <para>
            Ebben a feladatban egy meglévő programban kellett hibát keresni, és azt kijavítani. Először is elmondanám azt, hogy ha egy
		tevékenységre jobb egérgombbal rákattintunk, akkor létre tudunk hozni egy új altevékenységet. Ha pedig erre a tevékenységre 
		kétszer rákattintunk, akkor át tudjuk nevezni az adott tevékenységet. Én egy olyan hibát találtam, hogy 
		ha létrehozunk egy Új altevékenységet, azzal még nincs semmi gond, mivel minden probléma nélkül létrehozza a program. 
		Azonban ha azt a tevékenységet átnevezzük, akkor a program nem átnevezi a tevékenységet, hanem létrehoz egy másik
		altevékenységet ugyan azzal a névvel. Ezt láthatjuk az első két fényképen:
        </para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/uj1.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	    
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/uj2.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	Érzékelhető, hogy ha kellően sok új altevékenységet hoznánk létre és neveznénk át,
		akkor a végeredmény egy átláthatatlan mappahalom lenne, aminek senki se örül. A hiba javítása elég egyszerű volt.
		Először is ki kell keresni, hogy hol történik a forráskódban maga az átnevezés. Ez a TextFieldTreeCell osztályon belül
		az <function>editCell()</function> metóduson belül történik, ami a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[private void editCell() {

            if (getItem() == null) {
                return;
            }

            String oldText = getItem().toString();
            textField.setText(oldText);
            
            textField.setOnKeyReleased((javafx.scene.input.KeyEvent t) -> {
                if (t.getCode() == javafx.scene.input.KeyCode.ENTER) {

                    String newText = textField.getText();

                    java.io.File newf = new java.io.File(newText);
                    java.io.File oldf = new java.io.File(oldText);
                    try {
                        if (oldf.isDirectory()) {
                            //newf.mkdir();
                            oldf.renameTo(newf);
                        } else {
                            newf.createNewFile();
                        }
                    } catch (java.io.IOException e) {

                        System.err.println(e.getMessage());

                    }

                    commitEdit(newf);
                } 
                
            });

        }]]>	    
	</programlisting>
	<para>
		Itt a <emphasis>newf.mkdir();</emphasis> parancsot kellett átírni arra hogy <emphasis>oldf.renameTo(newf)</emphasis>
		Ez ténylegesen annyit jelent, hogy egy új mappa létrehozása helyett a régi mappát nevezze át az újra. Ezek után már 
		normálisan működik az átnevezés, ami a képeken is látható:
	</para>
	    
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/uj3.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	    
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/uj4.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	Egy másik hiba az az, hogy ha létrehozunk egy új altevékenységet, akkor amíg át nem nevezzük azt, addig nem tudunk
		létrehozni mégegyet, mivel az új altevékenység név már létezik. Erről a program csak annyi tájékoztatást ad a felhasználónak,
		hogy nem sikerült létrehozni a tevékenységet, ahogy az a képen is látható:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/create1.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
		Ezt is viszonylag könnyű javítani. A <emphasis>TextFieldTreeCell</emphasis> osztályon belül létre kellett hozni egy
		számlálót, aminek jelen esetben az i nevet adtam, majd pedig amikor meghatározza a program a fájl nevét, akkor a végére még
		hozzáfűzzük i-t. Ezek után egy while cikluson belül ellenőrizzük, hogy sikerült e létrehozni az altevékenységet, azaz a mappát.
		Ha sikerült akkor megszakítjuk a ciklust és haladunk tovább, ha viszon nem, akkor növeljük i értéket 1-el és újrapróbáljuk.
		Maga a kódcsipet a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[public TextFieldTreeCell(javafx.scene.control.TextArea propsEdit) {
            this.propsEdit = propsEdit;
            javafx.scene.control.MenuItem subaMenuItem = new javafx.scene.control.MenuItem("Új altevékenység");//"New subactivity");
            addMenu.getItems().add(subaMenuItem);
            subaMenuItem.setOnAction((javafx.event.ActionEvent evt) -> {
                java.io.File file = getTreeItem().getValue();

                boolean sikerulte = false;
                java.io.File f;

                int i = 1;
                while(true){
                f = new java.io.File(file.getPath() + System.getProperty("file.separator") + "Új altevékenység"+ i);

                if (f.mkdir()) {
                    javafx.scene.control.TreeItem<java.io.File> newAct
 //                           = new javafx.scene.control.TreeItem<java.io.File>(f, new javafx.scene.image.ImageView(actIcon));
                           = new FileTreeItem(f, new javafx.scene.image.ImageView(actIcon));                            
                    getTreeItem().getChildren().add(newAct);
                    sikerulte = true;
                    break;
                } else {
                    i++;
                }
            }

            if(!sikerulte){
                System.err.println("Cannot create " + f.getPath());
            }
            });]]>	
	</programlisting>
	    <para>
		Valamint kép a működésről:
	    </para>
	    <mediaobject>
            <imageobject>
		<imagedata fileref="pic/create2.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title>
        <para>
	Mutassunk rá a scanf szerepére és használatára! https://github.com/nbatfai/robocar-
emulator/blob/master/justine/rcemu/src/carlexer.ll
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll</link>                
        </para>
        <para>
            Ebben a feladatban a megadott forrásban meg kell magyarázni azt, hogy mi a szerepe az <function>sscanf()</function>-nek. Ebben a forráskóban összesen 10-szer fordul elő az <function>sscanf()</function>. Ebből most megmutatnék egy párat:
        </para>
	<programlisting>
	<![CDATA[{POS}{WS}{INT}{WS}{INT}{WS}{INT}	{
					  std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);
					  m_cmd = 10001;
					}
{CAR}{WS}{INT}				{
					  std::sscanf(yytext, "<car %d", &m_id);
					  m_cmd = 1001;
					}
{STAT}{WS}{INT}				{
					  std::sscanf(yytext, "<stat %d", &m_id);
					  m_cmd = 1003;
					}
{GANGSTERS}{WS}{INT}			{
					  std::sscanf(yytext, "<gangsters %d", &m_id);
					  m_cmd = 1002;
					}]]>
	</programlisting>
	<para>
	Ezekről lenne tehát szó. Ahhoz viszont, hogy megértsük, hogy itt mi a feladatuk, először is azt kéne tudnunk, hogy mit is csinál a <function>sscanf()</function>. Az <function>sscanf()</function> egy fájlkezelő függvény, amelyet arra szoktak használni, hogy  a standard input, vagy billentyűzet helyett formázott inputot olvassanak egy Stringből, vagy bufferből. A deklarálása a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[int sscanf( const char* buffer, const char* format, ... );]]>
	</programlisting>

	<para>
	Ahol a buffer tartalmazza az olvasandó adatot, a format pedig a beolvasandó adat formája.
	A formák jelölései mellesleg a következőek lehetnek: %c - karakter | %s - String | %d - decimális szám | %i - integer | %u - unsigned decimális szám | %o - oktális integer | %x - hexadecimális integer | %a %e %f %g - lebegőpontos szám | %n - az eddig olvasott karakterek számát adja vissza.
	</para>

	<para>
Ezek alapján nézzük meg a forráskódban található legelső <function>sscanf()</function>-et, ami a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);]]>
	</programlisting>
	<para>
	Akkor az előbbiek alapján ez a függvény a <emphasis>yytext</emphasis> bufferből kellene hogy beolvassa az adatokat, amiknek a formája úgy néz ki, hogy először egy <![CDATA["<pos"]]> szöveg van benne, majd egy %d ami egy decimális számot jelöl, valamit két darab %u, amik egy-egy unsigned int-et jelölnek. A decimális szám értékét az m_id változónak, az első unsigned int értékét a from változónak, a második unsigned int értékét pedig a to változónak adja át a függvény. De nézzünk meg egy másikat is, ami pedig a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[std::sscanf(yytext, "<init guided %s %d %c>", name, &num, &role);]]>
	</programlisting>

	<para>
	Itt szintén a yytext-ből olvassuk az adatokat, amiknek úgy kell kinéznie, hogy először egy <![CDATA["<init guided]]> szövegnek kell jönnie, aztán pedig egy %s-nek, ami egy Stringet jelöl, majd pedig egy decimális szám, amit ugye a %d jelöl, és végül pedig egy karaktert kell olvasnia, amit a %c jelöl. A String értékét a name változónak, a decimális szám értékét a num változónak, a karakter értékét pedig a role változónak adja át a függvény.
	</para>
	
	<para>
	Ezzel pedig már az összes <function>sscanf()</function> feladatát meg tudjuk határozni a fentiek alapján.
	</para>
    </section>
   <section>
        <title>SamuCam</title>
        <para>
	Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
https://github.com/nbatfai/SamuCam
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/hello/SamuCam">https://github.com/raczandras/progbook/tree/master/src/prog2/hello/SamuCam</link>            
        </para>
        <para>
            Ebben a feladatban a webcan kezelését kellett megmutatni a megadott forrásban, ami Qt-t, valamint opencv-t használ. Éppen ezért ha saját magunk is ki szeretnénk próbálni a programot, akkor előbb fel kell telepítenünk a Qt-t, valamint az opencv-t is, amihez rengeteg segítség található az interneten, éppen ezért ebbe én most nem mennék bele, hanem kezdjük is a webkamera használatának az elemzését. Ehhez két forrásfájl lesz nekünk fontos. Az egyik a main.cpp, ami kevésbé fontos, a másik pedig a SamuCam.cpp, ami sokkal inkább fontosabb, éppen ezért kezdjük is a main-nel, amiben csak az alábbi pár sor fontos nekünk:
        </para>
	<programlisting>
	<![CDATA[std::string videoStream = parser.value ( webcamipOption ).toStdString();
  SamuLife samulife ( videoStream, 176, 144 );]]>
	</programlisting>
	<para>
	Itt az történik, hogy a felhasználó által megadott ip címet felhasználja ahhoz, hogy elkezdődhessen a videózás.
	</para>
	
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/samu.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>BrainB</title>
        <para>
	Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: https://github.com/nbatfai/esport-talent-search
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>OSM térképre rajzolása</title>
        <para>
	Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC hekkereket: https://www.twitch.tv/videos/182262537 (de az OOCWC Java Swinges
megjelenítőjéből: https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin
is kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>
