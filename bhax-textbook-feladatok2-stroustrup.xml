<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>JDK osztályok</title>
        <para>
	Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/boost.cpp">https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/boost.cpp</link>                
        </para>
        <para>
            Ebben a feladatban egy Boost c++ programot kellett írni, ami kilistázza a JDK osztályait. Lássuk is, hogy hogyan történik ez. A program elején létrehozunk egy db (darab) nevű változót, amivel a .java végződésű fájlok mennyéségét fogjuk nyílván tartani. Ez után jön a <function>read_file()</function> nevű függvény, de én előbb a main-ről szeretnék beszélni:
        </para>
	<programlisting>
	<![CDATA[int main( int argc, char *argv[]){
	string path="java";
	vector<string> folders;
	read_file(path, folders);
	cout << "A JDK osztályainak a száma: " << db << "\n";
}]]>
	</programlisting>
	<para>
	A main-ben a path változó tárolja a gyökérmappa nevét, amiből kiindulva számoljuk, illetve listázzuk a nekünk kellő fájlokat. Ez után jön egy vektor, amiben a mappák neveit fogja tárolni a program. Majd meg is hívja a program a <function>read_file()</function> függvényt, aminek az egyik argumentuma a path változó, a másik pedig a folders lista lesz. Majd ha a függvény elvégezte a dolgát, akkor egy szimpla cout-tal kiíratjuk a JDK osztályainak a darabszámát. Maga a <function>read_file()</function> függvény pedig a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[int db = 0;
void read_file (boost::filesystem::path path, vector<string> folders){
	if(is_regular_file(path)){
		string ext(".java");
		if(!ext.compare(boost::filesystem::extension (path))) {
			string file=path.string();
			size_t end = file.find_last_of("/");
			string folder = file.substr(0,end);

 			folders.push_back(folder);
			cout << file << "\n";
			db++;
		}
 	}
	else if(is_directory(path))
 		for( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator (path))
			 read_file(entry.path(), folders);
}]]>
	</programlisting>
	<para>
	Először is megvizsgálja a program, hogy az aktuális path az mappa vagy fájl e. Ha mappa, akkor egy for ciklussal a mappán belüli összes fájlra meghívja saját magát rekurzívan. Ha viszont az aktuális path egy fájlt tartalmaz, akkor megnézzük, hogy .java-ra végződik e a fájl neve. Ha nem, akkor nem csinálunk vele semmit, de ha igen, akkor a file nevű változó értékének adjuk a fájl nevét, aztán létrehozunk egy end változót, ami annak a mappának az elérési útjának a hosszát fogja tartalmazni, amiben a fájl van. Majd pedig egy folder változó értéke lesz annak a mappának az elérési útja, amit a <function>substr()</function> függvénnyel oldunk meg. Ezek után a mappa elérési útját beletesszük a folders vektorba, kiíratjuk a fájl pontos elérési útját, és megnöveljük eggyel a db számlálót. A program működés közben pedig a következőképpen néz ki:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/boost.png" contentwidth="5in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
	Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/mozgat.cpp">https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/mozgat.cpp</link>             
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Hibásan implementált RSA törése + Összefoglaló</title>
        <para>
	Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
készített titkos szövegen.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
	Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4 hét/Perceptron osztály feladatot is.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

   <section>
        <title>Összefoglaló</title>
        <para>
	Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
        </para>
        
        <para>
            Hibásan implementált RSA törése
        </para>
    </section>

</chapter>
