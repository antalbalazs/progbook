<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
    <section>
        <title>JDK osztályok</title>
        <para>
	Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/boost.cpp">https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/boost.cpp</link>                
        </para>
        <para>
            Ebben a feladatban egy Boost c++ programot kellett írni, ami kilistázza a JDK osztályait. Lássuk is, hogy hogyan történik ez. A program elején létrehozunk egy db (darab) nevű változót, amivel a .java végződésű fájlok mennyéségét fogjuk nyílván tartani. Ez után jön a <function>read_file()</function> nevű függvény, de én előbb a main-ről szeretnék beszélni:
        </para>
	<programlisting>
	<![CDATA[int main( int argc, char *argv[]){
	string path="java";
	vector<string> folders;
	read_file(path, folders);
	cout << "A JDK osztályainak a száma: " << db << "\n";
}]]>
	</programlisting>
	<para>
	A main-ben a path változó tárolja a gyökérmappa nevét, amiből kiindulva számoljuk, illetve listázzuk a nekünk kellő fájlokat. Ez után jön egy vektor, amiben a mappák neveit fogja tárolni a program. Majd meg is hívja a program a <function>read_file()</function> függvényt, aminek az egyik argumentuma a path változó, a másik pedig a folders lista lesz. Majd ha a függvény elvégezte a dolgát, akkor egy szimpla cout-tal kiíratjuk a JDK osztályainak a darabszámát. Maga a <function>read_file()</function> függvény pedig a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[int db = 0;
void read_file (boost::filesystem::path path, vector<string> folders){
	if(is_regular_file(path)){
		string ext(".java");
		if(!ext.compare(boost::filesystem::extension (path))) {
			string file=path.string();
			size_t end = file.find_last_of("/");
			string folder = file.substr(0,end);

 			folders.push_back(folder);
			cout << file << "\n";
			db++;
		}
 	}
	else if(is_directory(path))
 		for( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator (path))
			 read_file(entry.path(), folders);
}]]>
	</programlisting>
	<para>
	Először is megvizsgálja a program, hogy az aktuális path az mappa vagy fájl e. Ha mappa, akkor egy for ciklussal a mappán belüli összes fájlra meghívja saját magát rekurzívan. Ha viszont az aktuális path egy fájlt tartalmaz, akkor megnézzük, hogy .java-ra végződik e a fájl neve. Ha nem, akkor nem csinálunk vele semmit, de ha igen, akkor a file nevű változó értékének adjuk a fájl nevét, aztán létrehozunk egy end változót, ami annak a mappának az elérési útjának a hosszát fogja tartalmazni, amiben a fájl van. Majd pedig egy folder változó értéke lesz annak a mappának az elérési útja, amit a <function>substr()</function> függvénnyel oldunk meg. Ezek után a mappa elérési útját beletesszük a folders vektorba, kiíratjuk a fájl pontos elérési útját, és megnöveljük eggyel a db számlálót. A program működés közben pedig a következőképpen néz ki:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/boost.png" contentwidth="5in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>Másoló-mozgató szemantika + Összefoglaló</title>
        <para>
	Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/mozgat.cpp">https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/mozgat.cpp</link>             
        </para>
        <para>
            Ebben a feladatban össze kellett vetni a C++11 másoló és mozgató szemantikáját. Ezt láncolt listákkal oldottam meg. Itt most a forráskódot nem a legelejétől kezdve a legvégéig haladva szeretném elemezni és bemutatni, hanem kicsit össze-vissza, de remélem érthető lesz. A legelső Láncolt Lista létrehozásánál még nem történik semmi különleges dolgot, szimplán csak alapértelmezett konstruktor (ctor) hívódik meg, ami létrehozza az üres listát. Ez úgy történik, hogy létrehozza a lista fejét egy új <emphasis>ListaElem()</emphasis>-ként, aminek jelen esetben null lesz az értéke. Mivel a Láncolt Listák úgy működnek, hogy a lista legelején a fej van, ami a lista első elemének a memóriacímét tárolja, vagyis a lista első elemére mutat. A lista minden elemére igaz, kivéve a fejet, amit az előbb megmagyaráztam, hogy két részből áll, egy érték, aminek a neve ebben az esetben adat illetve egy mutató részből, aminek pedig ebben a forráskódban kovetkezo a neve. Nyílvánvalóan az érték rész tárolja a lista aktuális elemének az értékét, a mutatórész pedig a lista következő elemének a memóriacímét (hogy mire nem jó az Adatszerkezetek és Algoritmusok óra). Valamint még a konstruktoron belül kiiratjuk a konzolra, hogy ctor, egyfajta nyomonkövetésként, és jelezve, hogy itt az alapértelmezett konstruktor működik. A forráskód során ez több helyen is előfordul.
        </para>
	<programlisting>
	<![CDATA[Lista(){
   	   std::cout << "ctor" << std::endl;
	   fej = new ListaElem();
	}]]>
	</programlisting>
	<para>
	Ennek a listának a <function>void beszur()</function> metódussal adunk értékeket. Ebben a metódusban először is a <emphasis>ListaElem* kovelem</emphasis>-nek a fejet adjuk át, mivel ennek a segítségével fogjuk meghatározni azt, hogy hova szúrjuk be az új elemet. Egy while ciklus a kovetkezo mutatókat felhasználva végig megy a listán, vagyis addig az elemig, aminek a kovetkezo mutatójának az értéke null. Aztán létrehoz egy új ListaElem-et, aminek a memóriacímét átadja a Lista jelenlegi utolsó elemének a kovetkezo mutatójának. Ezáltal a beszúrandó elem lesz a lista új utolsó eleme. Végül pedig az új elem értékének megadja a kívánt értékét, a kovetkezo mutatóját medig nullptr-re állítja.
	</para>
	<programlisting>
	<![CDATA[void beszur(int ertek){
	   ListaElem* kovElem = fej;
	   while(kovElem->kovetkezo != NULL){
		kovElem = kovElem->kovetkezo;
	   }
	   ListaElem* beszurElem = new ListaElem();
	   kovElem->kovetkezo = beszurElem;
	   beszurElem->adat = ertek;
	   beszurElem->kovetkezo = nullptr;
	}]]>
	</programlisting>
	<para>
	A destruktor pedig úgy működik, hogy a lista fejéből kiindulva végig megy a listán egy while ciklussal, és a delete operátorral mindig törli az aktuális elemet. Maga delete egy olyan operátor, ami a new kifejezés által létrehozott objektumok törlésére használatos. Vagyis, a destruktorban a lista minden olyan eleme, amelyre mutat egy pointer, törlésre kerül, és felszabadul a memória. És mivel vagy a lista fejéről beszélünk, vagy pedig egy olyan elemről, amelyre egy kovetkezo pointer mutat, így a lista összes eleme törlésre kerül.
	</para>
	<programlisting>
	<![CDATA[~Lista(){
	   ListaElem* elem = fej;
	   while(elem){
		ListaElem* akt_elem = elem;
		elem = elem->kovetkezo;
		delete akt_elem;
	   }
	}]]>
	</programlisting>
	<para>
	Van még egy, a bizonyítást, és a követhetőséget megkönnyítő függvényünk, ami a <function>kiir_memcim()</function> metódus. Ez a metódus egy while ciklust használ, ami addig megy, amíg nem találkozik egy null értékkel. Addig pedig minden egyes elemnek kiírja a memóriacímét, majd pedig átlép a lista következő elemére.
	</para>
	<programlisting>
	<![CDATA[void kiir_memcim(){
	   ListaElem* elem = fej->kovetkezo;
	   while(elem != NULL){
	   	std::cout << elem->adat << "\t" << elem << std::endl;
	   	elem = elem->kovetkezo;
	   }
	}]]>
	</programlisting>
	<para>
	A második listánk, azaz a lista2 létrehozásakor a másoló konstruktor (azaz copy ctor) hívódik meg, és a paraméterül kapott első lista értékeit mély másolással kapja meg a második lista. A másoló konstruktor egy olyan konstruktor, ami úgy hoz létre egy objektumot, hogy inicializálja egy korábban létrehozott azonos osztályú objektummal. A másoló konstruktor több dolgot is szokott csinálni. Például inicializál egy objektumot egy azonos típusú objektumból. Másolhat egy objektumot azért, hogy argumentumként továbbítsa azt egy függvénynek. És másolhat egy objektumot azért, hogy visszatérítse azt egy függvényből. Ha a másoló konstruktor nincs definiálva egy osztályban, akkor a fordító fog definiálni egyet. Ha egy osztály rendelkezik mutatókkal, és dinamikus memória-allokációkkal, akkor muszáj lennie másoló konstruktornak is. Látható, hogy ebben az esetben meghívódik a <function>masol()</function> nevű függvény, aminek a paramétere a régi lista feje lesz.
	</para>
	<programlisting>
	<![CDATA[Lista(Lista& regi){
	   std::cout << "copy ctor" << std::endl;
	   fej = masol(regi.fej);
	}]]>
	</programlisting>
	<para>
	A <function>masol()</function> metódus létrehoz egy új üres listaelemet ujElem néven, majd pedig, ha a paraméterként kapott ListaElem mutató értéke nem null, akkor az új elemnek lefoglaljuk a memóriát, és az adatértékének pedig megadjuk a paraméterként kapott elem adatértékét. Aztán ha a paraméterként kapott elemnek van rákövetkezője, akkor meghívjuk rekurzívan a <function>masol()</function> függvényt, aminek ezúttal az eredetileg paraméterként kapott elem rákövetkezője lesz a paramétere. Ha pedig a paraméterként kapott elemnek nincs rákövetkezője, akkor az új elem kovetkezo mutatóját nullpt-re állítjuk. Végül pedig visszaadja a metódus az új elemet.
	</para>
	<programlisting>
	<![CDATA[ListaElem* masol(ListaElem* elem){
	   ListaElem* ujElem;
	   if(elem != NULL){
		ujElem = new ListaElem();
		ujElem->adat = elem->adat;
		if(elem->kovetkezo != NULL){
		   ujElem->kovetkezo=masol(elem->kovetkezo);
		}
		else{
		   ujElem->kovetkezo = nullptr;
		}		
	   }
		return ujElem;	
	}]]>
	</programlisting>
	<para>
	A lista3 létrehozásánál ismét az alapértelmezett konstruktor, azaz ctor kerül meghívásra, vagyis létrejön egy üres listafej. Ezek után azonban itt a lista3=lista; utasítással már másoló értékadás, azaz copy assign történik. A másoló értékadásnál a cél, azaz a bal oldal, és a forrás, azaz a jobb oldal azonos osztály típusú. Itt is igaz az, hogy ha mi nem definiáltunk, akkor a fordító fog létrehozni egyet. Az alapértelmezettnél egy tagonkénti másolás történik, ahol minden tagot a saját másoló operátora másolja. Abban különbözik a másoló konstruktortól, hogy mielőtt megtörténne a másolás, az előtt törölnie kell a pointerünk által mutatott objektumot.
	</para>
	<programlisting>
	<![CDATA[Lista& operator=(const Lista& regi){
	   std::cout << "copy assign" << std::endl;
	   fej = masol(regi.fej);
	   return *this;
	}]]>
	</programlisting>
	<para>
	A negyedik listát (lista4) úgy hozzuk létre, hogy lista lista4 = std::move(lista3);. Ebben az esetben a mozgató konstruktor, azaz move ctor hívódik meg, mivel az std::move() jobbértékké alakítja a lista3-at. Maga a mozgató konstruktor a C++11-től létezik, és a másoló konstruktorral ellentétben nem az a dolga, hogy hogy egy objektum tartalmát átmásolja egy másikba. Akkor használunk mozgató konstruktort, amikor azt akarjuk, hogy az új objektum tulajdonképpen annyi erőforrást "lopjon" el az eredeti objektumtól, amennyit csak tud, minél gyorsabban, mivel az eredetinek már nincs jelentősége, mert úgy is törlésre kerül. A mi esetünkben az új lista fejének a <function>std::move()</function> függvénnyel átadjuk a régi lista fejét, majd pedig a régi lista fejét nullptr-re állítjuk.
	</para>
	<programlisting>
	<![CDATA[Lista(Lista&& regi){
	   std::cout << "move ctor" << std::endl;
	   fej = std::move(regi.fej);
	   regi.fej = nullptr;
	}]]>
	</programlisting>
	<para>
	Az ötödik, és egyben utolsó listánknál, azaz lista5-nél pedig először szintén az alapértelmezett konstruktor hívódik meg, majd pedig az <function>std::move()</function> függvény jobbértékűvé alakítja lista4-et, és az értékeit pedig mozgató értékadással kapja meg lista5
	</para>
	<programlisting>
	<![CDATA[Lista& operator=(Lista&& regi){
	   std::cout << "move assign" << std::endl;
	   fej = regi.fej;
	   regi.fej = nullptr;
	   return *this;
	}]]>
	</programlisting>
	<para>
	A program futásáról készült képen pedig jól látható, hogy a mozgató konstruktorral, és mozgató értékadással létrejött listák esetén a lista új memóriablokkba került, míg a mozgató konstruktorral és mozgató értékadással létrejött listák pedig ugyan abban a memóriablokkban lettek eltárolva, mint elődjeik.
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/mozgat.png" contentwidth="5in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>Hibásan implementált RSA törése</title>
        <para>
	Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
készített titkos szövegen.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/Rsa">https://github.com/raczandras/progbook/tree/master/src/prog2/Stroustrup/Rsa</link>             
        </para>
        <para>
           Ebben a feladatban egy hibásan implementált RSA titkosítás törését kellett végrehajtani. Kezdjük is a feladat titkosítási részével. Először is ellenőrizzük, hogy kettő e az argumentumok száma, nyílván az első argumentum lesz a szöveg amit titkosítani szeretnénk, a második argumentum pedig az a fájl, amibe kiirjuk a titkosított szöveget. Amennyiben az argumentumok számával nincs gond, akkor létrehozunk egy KulcsPar objektumot, és egy tisztaszöveg változót, amibe a try blokkon belül be is olvassuk a titkosítandó szöveget, és létrehozunk egy File típust, ami pedig az a fájl lesz, amibe kiirjuk a titkosított szöveget, illetve létrehozunk egy PrintWritert is, amivel pedig majd kiirjuk a szöveget a megfelelő fájlba. Ezek után a tisztaszoveg-et átalakítjuk kisbetűssé, mivel a nagy betűk külön lennének titkosítva, ami megnehezítené a szöveg törését. Ezek után pedig a két for cikluson belül megtörténik a titkosítás, valamint a titkosított szöveg kiírása a megadott fájlba. Ezen kívűl van még egy KulcsPar osztálya is a forrásnak, ami pedig a titkosítás matematikai részét végzi.
        </para>
	<programlisting>
	<![CDATA[public class Rsa {
	
	public static void main(String[] args) {
		if(args.length != 2){
			System.out.println("usage: java Rsa input output");
			System.exit(-1);
		}
		KulcsPar kulcs = new KulcsPar();
		String tisztaszoveg;

		try{
			tisztaszoveg = new String (Files.readAllBytes( Paths.get(args[0])));
			File ki = new File(args[1]);
		
			PrintWriter kiir = new PrintWriter(args[1]);
			
			tisztaszoveg = tisztaszoveg.toLowerCase();

			for( int i = 0; i<tisztaszoveg.length(); i++){
				String szoveg = tisztaszoveg.substring(i, i+1);
				byte[] buffer = szoveg.getBytes();
				java.math.BigInteger[] titkos = new java.math.BigInteger[buffer.length];
				byte[] output = new byte[buffer.length];
				
				for( int j = 0; j< titkos.length; j++){
					titkos[j] = new java.math.BigInteger(new byte[] {buffer[j]});
					titkos[j] = titkos[j].modPow(kulcs.e, kulcs.m);
					output[j] = titkos[j].byteValue();
					kiir.print(titkos[j]);
				}
				kiir.println();
			}				
		}
		catch(IOException e){
			System.out.println("hiba " + e);
		}
	}
}

class KulcsPar {
	java.math.BigInteger d,e,m;
	public KulcsPar() {
		int meretBitekben = 700 * (int) (java.lang.Math.log((double) 10) / java.lang.Math.log((double) 2));

		java.math.BigInteger p = new java.math.BigInteger(meretBitekben, 100, new java.util.Random());
		java.math.BigInteger q = new java.math.BigInteger(meretBitekben, 100, new java.util.Random());

		m = p.multiply(q);
		java.math.BigInteger z = p.subtract(java.math.BigInteger.ONE).multiply(q.subtract(java.math.BigInteger.ONE));

		do {
			do {
				d = new java.math.BigInteger(meretBitekben, new java.util.Random());
			} while (d.equals(java.math.BigInteger.ONE));
		} while (!z.gcd(d).equals(java.math.BigInteger.ONE));
		e = d.modInverse(z);
	}
}]]>
	</programlisting>
	<para>
	A titkosított szöveg pedig a következőképpen néz ki:
	</para>
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/encoded.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
	<para>
	A program másik része a titkosított szöveg dekódolása. Ebben a forráskódban van egy KulcsPar osztály, aminek három tagváltozója van. Az első a values, ami az adott karakternek a titkosított értékét tárolja, a második a key, ami azt tárolja, hogy mi az adott dekódolt karakter, a harmadik pedig a freq, ami pedig a karakter előfordulásainak a számát tárolja. Ezen kívűl megtalálhatóak még a tagváltozók getterei, illetve setterei, valamint az <function>incFreq()</function> metódus is, ami az előfordulást növeli eggyel.
	</para>
	<programlisting>
	<![CDATA[class KulcsPar{
    private String values;
    private char key = '_';
    private int freq = 0;
    
    public KulcsPar(String str, char k){
        this.values = str;
        this.key = k;
    }

    public KulcsPar(String str){
        this.values = str;
    }

    public void setValue(String str){
        this.values = str;
    }

    public void setKey(char k){
        this.key = k;
    }

    public String getValue(){
        return this.values;
    }

    public char getKey(){
        return this.key;
    }

    public void incFreq(){
        freq += 1;
    }

    public int getFreq(){
        return freq;
    }
}]]>
	</programlisting>
	<para>
	Valamint megtalálható a main is, amiben pedig először is megadjuk a programnak, hogy hol van a titkosított fájl, majd pedig létrehozunk egy lines tömböt, amibe be is olvassuk egy while ciklussal a titkosított fájl sorait. Ezek után létrehozunk egy KulcsPár tömböt, egy volt logikai változót, amiben azt fogjuk tárolni, hogy az adott sor szerepel e már a kulcspár tömbben. Majd pedig két egymásba ágyazott for ciklussal, ha már egy adott sor szerepel a tömbünkben, akkor csak növeljük az előfordulásainak a számát eggyel, ha viszont még nem szerepel a tömbben, akkor példányosítunk egy új kulcspárt a tömbbe, aminek beállítjuk a values tagváltozójának az értékét az adott sor értékére. Ezek után rendezzük a kulcspár tömböt az előfordulások száma alapján csökkenő sorrendbe.
	</para>
	<programlisting>
	<![CDATA[ public static void main(String[] args) {
        try {
            BufferedReader inputStream = new BufferedReader(new FileReader(args[0]));
            int lines = 0;

            String line[] = new String[10000];

            while((line[lines] = inputStream.readLine()) != null) {
                lines++;
            }

            inputStream.close();

            KulcsPar kp[] = new KulcsPar[100];

            boolean volt = false;
            kp[0] = new KulcsPar(line[0]);
            int db = 1;

            for(int i = 1; i < lines; i++) {
                volt = false;
                for(int j = 0; j < db; j++) {
                    if(kp[j].getValue().equals(line[i])) {
                        kp[j].incFreq();
                        volt = true;
                        break;
                    }
                }

                if(volt == false) {
                    kp[db] = new KulcsPar(line[i]);
                    db++;
                }
            }

            for(int i = 0; i < db; i++) {
                for(int j = i + 1; j < db; j++) {
                    if(kp[i].getFreq() < kp[j].getFreq() ) {
                        KulcsPar temp = kp[i];
                        kp[i] = kp[j];
                        kp[j] = temp;
                    }
                }
            }]]>
	</programlisting>
	<para>
	Ezek után beolvassuk azt a fájlt, amiben sorrendbe vannak rakva a karakterek gyakoriság alapján. Az én esetemben ez a betugyakorsag.txt nevű fájl. Ezeket a karaktereket belehelyezzük egy karakter tömbbe, és egy while ciklussal a kulcsPár példányoknak a key tagváltozóját beállítjuk a megfelelő karakterekre. Végül pedig végigmegyünk a lines tömbbön, és az alapján kiiratjuk a kp tömbből a megfelelő karaktereket. Én a szöveghez egy angol szöveg generátort használtam, a betűgyakoriság meghatározásához pedig <link xlink:href="https://www.browserling.com/tools/letter-frequency">ezt a weboldalt</link>. A végeredmény pedig a következőképpen néz ki:
	</para>	
	<mediaobject>
            <imageobject>
		<imagedata fileref="pic/decoded.png" contentwidth="7in"/>
            </imageobject>
        </mediaobject>
    </section>

   <section>
        <title>Összefoglaló</title>
        <para>
	Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
        </para>
        
        <para>
            Másoló-mozgató szemantika
        </para>
    </section>

</chapter>

