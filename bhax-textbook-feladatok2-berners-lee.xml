<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0 I-II</title>
        <para>
            1. hét: Az objektumorientált paradigma alapfoglamai. Osztály, objektum, példányosítás
        </para>
	<para>
	Először értsük meg, hogy mi is az objektum, és hogy keletkezik, és mi játszik fontos szerepet a működésében. Az objektum a java programozási nyelv alapvető eleme, éppen ezért a Java egy objektum orientált programozási nyelv. Az objektum a valódi világ egy elemének a rá jellemző tulajdonságai és viselkedései által modellezett eleme. Az objektumokkal általában valamilyen feladatot szeretnénk megoldani. Egy objektum tulajdonságokból(változók), és viselkedésekből(metódusok) áll. A változókkal írhatjuk le az adott objektum állapotát, minden egyednek saját készlete van a változókból, éppen ezért ezeket példányváltozóknak nevezzük. A metódus nagyrészt hasonlít egy függvényre. Azaz utasításokat hajt végre, kaphat paramétereket, és egy értékkel tér vissza.
	Az osztályok pedig az azonos típusú objektumok modelljét írják le. A program a működése során példányosítja az osztályokat, azaz konkrét objektumokat hoz létre, vagyis amikor egy objektumot létrehozunk, azt valójában egy osztályból hozzuk létre. Amikor egy új egyedet szeretnénk létrehozni, akkor azt a konstruktor fogja felépíteni.
	Az előzőekben említettem, hogy a változókat a metódusok kezelik. Azonban alaphelyzetben ez nem igaz. Ha csak úgy megírunk egy osztályt, akkor annak a változóihoz kívülről is hozzá lehet férni, a metódosuk figyelembe vétele nélkül. Ez pedig nem jó dolog. Ahhoz, hogy egy objektum biztonságos legyen, priváttá kell tennünk a változóit, ezáltal scak az adott objektum férhet hozzá a saját változóihoz közvetlenül. Minden más csak a metódusain keresztül férhet hozzájuk.
	Az, hogy a változók és metódusok egy helyen vannak tárolva az osztályokban (egységbe zárás), valamint az, hogy egy objektum változóihoz csak ellenőrzött körülmények között lehet hozzáférni (egységbe zárás) eggyüttesen az adatabsztrakciót, azaz az objektumorientált paradigma egyik alapját alkotják.
	</para>
	<para>
	2. hét: Öröklődés, osztályhierarchia. Polimorfizmus, metódustúlterhelés. Hatáskörkezelés. A bezárási eszközrendszer, láthatósági szintek. Absztrakt osztályok és interfészek.
	</para>
	<para>
	A legegyszerűbb példa az öröklődésre az az, amikor egy osztály egy már meglévő osztály kiterjesztéseként definiálunk. Ez lehet új műveletek, vagy új változók bevezetése is, maga az osztály pedig lehet public, illetve nem public is. Az eredeti osztályt szülőosztálynak, a kiterjesztettet pedig gyermek osztálynak nevezzük. A gyermekosztály megörökli a szülőosztály változóit és metódusait, ha a láthatósági szintje az adott változónak/metódusnak lehetővé teszi azt. A láthatósági szint lehet public, ami azt jelenti, hogy az adott változót vagy metódust nem csak a gyermek osztályok, hanem bármely másik osztály objektumai is elérik. A láthatósági szint lehet protected is. Ebben az esetben már csak az adott osztályból kiterjesztett gyermekosztályok érik el őket. A harmadik lehetőség pedig a private, amikor pedig csak a szülőosztály objektumai tudják elérni az adott változót/metódust.  Azonban a gyermek osztály nincs csupán ezekre korlátozva, vagyis a gyermekosztályoknak lehetnek saját változói ,és metódusai, illetve fel is tudják írni a szülőtől örökölt metódusokat. 
	</para>
	<para>
	Mivel a gyermek osztály a szülő osztály minden változójával és metódusával rendelkezik, ezért használhatóak minden olyan esetben, amikor a szülő használható. Egy változó pedig nem csak a deklarált típusú, hanem egy leszármazott objektumra is hivatkozhat. Ezt polimorfizmusnak, azaz többalakúságnak nevezzük.
	</para>
	<para>
	Ha egy kiterjesztett osztálybeli metódusnak ugyan az a szignatúrája, és visszatérési értéke, mint a szülőosztály metódusának, akkor a leszármazott osztály felűlírja a szülőosztály metódusát. Ez lehetővé teszi, hogy egy osztály örököljön egy olyan szülőosztálytól, aminek hasonló a viselkedése, majd szükség esetén ezen változtasson. A felülíró metódus neve, paramétereinek a száma és típusa megegyezik a felülírt metódussal.
	</para>
	<para>
	Alapértelmezetten egy újonnan létrehozott osztálynak az Object nevű osztály lesz az őse. Ez áll a Java osztályhierarchia csúcsán. Ebből kiindulva lehet ábrázolni az osztályok hierarchiáját egy fa adatszerkezetben.
	</para>
	<para>
	Lehetőség van Absztrakt osztályokat is létrehozni az <emphasis>abstract</emphasis> módosítóval. Az ilyen osztályok tartalmazhatnak absztrakt, azaz törzs nélküli metódusokat, amiket szintén az <emphasis>abstract</emphasis> módosítóval kell jelölni. Az ilyen osztályok nem példányosíthatóak, mivel a példányokra nem lenne értelmezve minden metódus. Ennek ellenére van értelme absztrakt típusú változókat és paramétereket deklarálni, mivel az ilyen változók az adott absztrakt osztály bármely leszármazottjának példányára hivatkozhatnak.
	</para>
	<para>
	3. hét: Modellező eszközök és nyelvek. AZ UML és az UML osztálydiagramja.
	</para>
	<para>
	Az UML, azaz Unified Modeling Language, vagy magyarul egységesített modellezőnyelv segítségével fejlesztési modelleket lehet szemléltetni. Egy integrált diagramkészletből áll, amelyet a szoftverfejlesztők számára fejlesztettek ki a programok megjelenítésére, felépítésére és dokumentálására. Az objektumorientált szoftverfejlesztési folyamat nagyon fontos részre. Többnyire grafikus jelöléseket használ a projektek tervezésére. Rengeteg diagram, azaz modell van hozzá.
Az UML használható bármelyik ma ismert programozási nyelvvel, mivel azoktól független absztrakciós szinten fogalmazza meg a rendszer modelljét. Maga az UML egy grafikus modellező nyelv, azaz a diagramok téglalapokból, vonalakból, ikonokból, és szövegből állnak.
	</para>
	<para>
	A szerkezeti diagramok a rendszer és annak részeinek statikus felépítését mutatják a különféle absztrakciós és megvalósítási szinteken, és hogyan kapcsolódnak egymáshoz. A szerkezetdiagram elemei egy rendszer értelmes fogalmait képviselik, és tartalmazhatnak absztrakt, valós és megvalósítási koncepciókat, hétféle szerkezeti diagram létezik az alábbiak szerint: Class Diagram, Component Diagram, Deployment Diagram, Object Diagram, Composite Structure Diagram, és Profile Diagram.
	</para>
	<para>
	A Class diagram egy központi modellezési technika, amely szinte minden objektum-orientált módszert átfut. A rendszerben található osztályokat, interfészeket, egyéb tipusokat, és a közöttük lévő kapcsolatot irja le. A Component Diagram a szoftverkomponensek architektúráját és az ezek közötti összefüggéseket mutatja meg. A Deployment Diagram egy objektum orientált program fizikai aspektusát mutatja meg, és modellezi a futási idejét. Az objektumdiagram a példányokat modellezi.

	</para>
    </section> 

<section>
        <title>Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++ nyelven</title>
        <para>
            1. hét: Az objektumok és osztályok C++ implementációja
	</para>
	<para>
	Az osztályok példányokat tárolnak, például különböző bankszámlák. Ezen kívűl megtalálhatóak a példányok tulajdonságai is, 
	mintpéldául a számlán lévő egyenleg, illetve a számlán végzett műveletek (pénz betétele, felvétele). Az ilyen egyedeket 
	nevezzük objektumoknak. Fontos, hogy egy objektum tulajdonságaihoz csak a műveletein keresztül lehessen hozzáférni. 
	Ha például egy bankszámla egyenlegét csak úgy át lehetne írni, az nem lenne jó hatással a társadalomra. 
	Éppen ezért az objektumok tulajdonságait és műveleteit egységbe kell zárni, illetve biztosítani kell, 
	hogy az objektum tulajdonságaihoz a program többi része ne tudjon hozzáférni. Ezt hívjuk adatrejtésnek. 
	Ha van egy madár, illetve egy papagáj osztályunk, akkor a két osztály között egyfajta kapcsolat van, mivel a papagáj maga
	is egy madár. Ezt nevezzük specializációnak. A madár általánosabb fogalom mint a papagáj. 
	Éppen ezért a speciálisabb osztály rendelkezik az általánosabb osztály tulajdonságaival és műveleteivel, másszóval örökli 
	őket. Szóval egy papagájt bármikor kezelhetünk madárként.
	Ez a három fogalom (adatrejtés, specializáció, öröklődés) alkotja az objektumorientált programozás alapelveit. 
	Azonban a C++-ban (sok OOP, köztük a JAVA nyelvvel ellentétben) megtalálható a típustámogatás is. Ez azt jelenti,
	hogy az osztályok ugyan úgy működhetnek, mint a beépített típusok.
        </para>
	<para>
	2. hét:
	</para>
	<para>
	C++ ban az öröklés során egy osztály specializált változatait hozzuk létre, amelyek öröklik a szülőosztály jellemzőit és viselkedését. Ezeket az osztályokat alosztályoknak nevezzük. Az alosztályok megváltoztathatják az öröklött tulajdonságokat, és új metódusokat is adhatunk hozzá (a Java nyelvhez hasonlóan. Az öröklődés fajtája lehet egyszeres öröklés, és többszörös öröklés is (az utóbbi a Java nyelvben csak az Absztrakt osztályok használatánál lehetséges). Az egyszeres öröklés esetén minden származtatott osztály pontosan egy közvetlen szülőosztály tagjait örökli, míg a többszörös öröklődés során a származtatott osztály több közvetlen szülőosztály tagjait örökli. Például létrehozhatunk egymástól független autó és hajó osztályokat, majd pedig ezekből örökléssel definiálhatunk egy kétéltű osztályt, ami egyaránt rendelkezik az autó és a hajó jellemzőivel és viselkedésével is. Ebben különbözik a C++ nagyon sok magasszintű programozási nyelvtől (Java, C# ...), mivel azok csak az egyszeres öröklést támogatják.
	</para>
	<para>
	Az osztályok tagjainak három fajta elérési szintje lehet: private, public, és protected. A private változókat és metódusokat csak az adott osztályon belüli objektumok tudják elérni. A public változókat és metódusokat bárhonnan, bármelyik osztály objektuma eléri. A protected változókhoz és metódusokhoz pedig csak az adott osztály, és annak a gyermek osztályaiban lévő objektumok tudnak hozzáférni (hasonlóan a Java nyelvhez). Az osztályok származtatásával kialakítható egy fa adatszerkezetre emlékeztető osztályhierarchia.
	</para>
	<para>
	A polimorfizmus, azaz többalakúság (hasonlóan a Java nyelvhez) azt jelenti, hogy egy adott szülőosztályból származtatott gyermek osztály megörökli a szülő minden változóját és metódusát, de ezek a szülő osztályban módosulhatnak. Ezt C++ ban a virtuális függvények teszik lehetővé. A virtuális függvények biztosítják, hogy egy adott osztály-hierarchiában egy adott függvénynek különböző verziói létezhessenek úgy, hogy csak a program futása során derüljön ki, hogy pontosan melyik függvényt kell használni.
	</para>
	<para>
	A java hasonlóságok újabb része a metódus túlterhelés. Ez azt jelenti, hogy van lehetőség ugyanazzal a névvel több különböző függvényt létrehozni, amennyiben a függvényeknek különböznek a paraméterlistái.
	</para>
	<para>
	Van lehetőség absztrakt osztályok létrehozására is. Ezeket az osztályokat csak továbbfejlesztésre, származtatásra lehet használni. Objektumpéldányokat nem készíthetünk velük, azonban objektumreferenciákat igen. Az absztrakt osztályokat az osztály fejlécében az <emphasis>abstract</emphasis> kulcsszó megadásával lehet létrehozni. Az absztrakt osztályok bizonyos műveletei, amelyek szükségesek az osztály működéséhez, általában nincsenek kidolgozva. Ebben az esetben a függvény deklarációt egy pontosvessző zárja, és nincs törzsük. Ezeknél a metódusoknál szintén alkalmazni kell az <emphasis>abstract</emphasis> kulcsszót. Ilyenkor az abstract metódusok implementációját a származtatott osztályban kell megtenni, vagy pedig a származtatott osztálynak is absztraktnak kell lennie.

	</para>
    </section>        
  

    <section>
        <title>Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba</title>
	<para>
            A Python programozási nyelvet Guido van Rossum alkotta meg 1990-ben. Maga a python egy magas szintű, dinamikus, objektumorientált, és platformfüggetlen programozási nyelv. Leginkább egyszerű alkalmazások készítésére használatos. Viszonylag könnyen meg lehet tanulni a használatát, ezért hamar el lehet vele érni látványos eredményeket. Különlegessége más nyelvekkel szemben (pl. C, C++, Java), hogy nincs szükség a programkód fordítására. Elegendő egy forrás fájlt megírni, és az automatikuson fut is. A python programok általában sokkal rövidebbek, mint ugyanazon programok C++ vagy Java nyelven. Ennek több oka is van. Egyrészt az adattípusai lehetővé teszik, hogy összetett kifejezéseket írjunk le rövid állításokban. Másrészt nincs szükség a változók definiálására. És végül, a (szarkazmus) legkedveltebb ok, hogy a python nyelv nem használ se zárójeleket, se pontosvesszőket. Ezek helyett a kód csoportosítása új sorral és tabulátorral történik. Pythonban egy programblokk végét egy kissebb behúzású sor jelzi, az utasítások pedig a sorok végéig tartanak. Éppen ezért nincs szükség pontosvesszőre. Ha viszont egy utasítás nem fér el egy sorban, akkor az adott sor végére egy \ jelet kell tenni, a megjegyzéseket pedig kettőskereszt jellel tujuk jelezni. 
        </para>
	<para>
	A python nyelvben a változók az objektumokra mutató referenciák. Egy változó hozzárendelését a del kulcsszóval tudjuk törölni, ha pedig egy objektumra már egy változó se mutat, akkor a garbage collector fogja törölni az adott objektumot. Érdekesség ezzel kapcsolatban, hogy a változóknak nem kell konkrét típust adnunk, mivel kitalálja, hogy mire gondolunk. Az adattípusok a következőek lehetnek: számok, sztringek, ennesek, listák, és szótárak.
	A számok lehetnek egészek, komplexek, és lebegőpontosak is, a sztringeket pedig idézőjelek, illetve aposztrófok közé írva lehet megadnunk.
	</para>
	<para>
	Maguk a változók lehetnek globálisak vagy lokálisak. Alapvetően a lokális az alapértelmezett, ezért ha azt szeretnénk, hogy egy változó globális legyen, akkor azt a változót a függvény elején kell felvenni, illetve eléírni a global kulcsszót.
	A különböző típusok közötti konverziók támogatottak, ha van értelmük. Például int, long, float, illetve complex típusok közötti konverzió. De sztringekből is képezhetünk számot. Ehhez csak a használt számrendszert kell megadni, pl: int. Ezeknek a változóknak a kiiratását a <function>print</function> függvénnyel lehet megoldani. Ha több változó értékét szeretnénk kiiratni, akkor vesszővel kell elválasztani őket egymástól. Ezeken kívül a python nyelvben ugyanúgy elérhetőek az elágazások, illetve a ciklusok is, mint más magasszintű programozási nyelvekben. A for, illetve a while ciklus is elérhető, azokon pedig a break, illetve a continue utasítások is használhatóak. Léteznek címkék, amiket a label kulcsszóval kell elhelyezni a kódban, majd pedig a kód más részeiről a goto utasítás használatával a labelhez ugorhatunk.
	</para>
	<para>
	Python nyelven a függvényeket a <emphasis>def</emphasis> kulcsszóval lehet definiálni. A függvényekre úgy is lehet tekinteni, mint értékekre, mivel továbbadhatóak más függvényeknek, és objektumkonstruktoroknak is. Ettől függetlenül a függvényeknek vannak paraméterei, amelyeknek adhatunk alapértelmezett értéket is. A legtöbb paraméter érték szerint adódik át, ezalól kivételek a mutable típusok, amelyeknek a függvényben történő megvalósítása hatással van az eredeti objektumra is. A függvény hívásánál a paraméterek úgy követik egymást, mint a függvény definíciójában. Emellett van lehetőség közvetlenül az egyes konkrét argumentumoknak értéket adni a függvény hívásakor, ha a zárójelben elé írjuk a változó nevét és egy egyenlőségjelet. A függvényeknek egy visszatérési értékük van.
	</para>
	<para>
	A Python nyelvben -más nyelvekhez hasonlóan- létrehozhatunk osztályokat, és ezekből példányosíthatunk objektumokat. Az osztályok tartalmazhatnak metódusokat, amiket akár örökölhetnek is más osztályokból. Az osztály metódusait ugyanúgy lehet definiálni, mint a globális függvényeket, azonban az első paraméterük a <emphasis>self</emphasis> kell hogy legyen, amelynek az értéke mindig az az objektumpéldány lesz, amelyen a metódust meghívták. Ezen kívűl az osztályoknak lehet egy speciális, konstruktor tulajdonságú metódusa, az <function>__init__</function>.
	</para>

	<para>
	Léteznek különböző modulok, amelyeknek a célja a fejlesztés megkönnyebbítése. ilyen például az <emphasis>appuifw</emphasis>, ami a felhasználói felület kialakításást, kezelését segíti. A <emphasis>messaging</emphasis> modul az SMS és MMs üzenetek kezelését segíti. A <emphasis>sysinfo</emphasis> a mobilkészülékekkel kapcsolatos információk lekérdezésére használható. A <emphasis>camera</emphasis> modullal lehet elvégezni minden, a készülék kamerájával kapcsolatos műveletet. Az <emphasis>audio</emphasis> modul pedig a hangfelvételek készítéséért és lejátszásáért felelős.
	</para>
	<para>
	Más nyelvekhez hasonlóan a Python nyelvben is van lehetőség a kivételkezelésre a <emphasis> try, except </emphasis> és opcionálisan egy <emphasis>else</emphasis> utasítással. A try kulcsszó után szerepel az a kódblokk, amelyben a kivétel előállhat. Ha bekövetkezik a hiba, akkor az except részre ugrik a program, és az ott lévő utasításokat hajtja végre.
	</para>
    </section>     
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
